import { Candle, CompletedTrade, Position, TradingSignal } from '@/types/trading';
import { ConditionEvaluator, ConditionGroup, getConditionDescription } from './condition-system';
import CompletedTradeRepository from './db/completed-trade-repository';
import OpenPositionRepository from './db/open-position-repository';
import { IndicatorEngine, IndicatorValues } from './indicator-engine';

/**
 * Custom Strategy - Flexible, condition-based trading strategy
 * Can be configured through UI without code changes
 */

export interface CustomStrategyConfig {
  name: string;
  description?: string;
  // Human-readable notes generated by AI
  longNotes?: string; // ðŸŸ¢ Conditions d'ACHAT (LONG)
  shortNotes?: string; // ðŸ”´ Conditions de VENTE (SHORT)
  strategyLogic?: string; // ðŸ’¡ Logique de la stratÃ©gie
  
  // Entry conditions
  longEntryConditions: ConditionGroup;
  shortEntryConditions: ConditionGroup;
  
  // Exit conditions (optional - will use TP/SL if not provided)
  longExitConditions?: ConditionGroup;
  shortExitConditions?: ConditionGroup;
  
  // Risk management
  profitTargetPercent: number;
  stopLossPercent: number;
  maxPositionTime: number; // milliseconds
  
  // Position sizing
  positionSize: number;
  
  // Active state (from DB)
  isActive?: boolean;
  
  // UI customization
  color?: string; // Tailwind color name (e.g., 'emerald', 'rose', 'indigo')
  
  // Cooldown between trades
  cooldownPeriod: number; // milliseconds
  
  // Strategy metadata
  strategyType: string; // e.g., 'CUSTOM', 'RSI_EMA', etc.
  
  // Timeframe
  timeframe: string; // e.g., '1m', '5m', '15m', '1h', '4h', '1d'
  
  // Simulation mode
  simulationMode: boolean;
}

export class CustomStrategy {
  private config: CustomStrategyConfig;
  private indicatorEngine: IndicatorEngine;
  private conditionEvaluator: ConditionEvaluator;
  
  // Position tracking
  private currentPosition: Position = {
    type: 'NONE',
    entryPrice: 0,
    entryTime: 0,
    quantity: 0,
    unrealizedPnL: 0,
    unrealizedPnLPercent: 0
  };
  
  // Performance tracking
  private totalPnL: number = 0;
  private totalTrades: number = 0;
  private winningTrades: number = 0;
  private initialCapital: number = 100000;
  
  // Trade timing
  private lastTradeTime: number = 0;
  
  // Completed trades
  private completedTrades: CompletedTrade[] = [];
  private entrySignal: TradingSignal | null = null;
  
  // Current indicators
  private currentIndicators: IndicatorValues | null = null;
  
  constructor(config: CustomStrategyConfig) {
    this.config = config;
    this.indicatorEngine = new IndicatorEngine();
    this.conditionEvaluator = new ConditionEvaluator();
  }
  
  /**
   * Analyze market and generate trading signals
   */
  analyzeMarket(candles: Candle[]): TradingSignal | null {
    if (candles.length < 200) {
      return null;
    }
    
    // Validate configuration
    if (!this.config.longEntryConditions || !this.config.shortEntryConditions) {
      console.error(`[${this.config.name}] Invalid strategy configuration - missing entry conditions`);
      return null;
    }
    
    // Calculate all indicators
    const indicators = this.indicatorEngine.calculate(candles);
    this.currentIndicators = indicators;
    
    const currentPrice = indicators.price;
    const timestamp = Date.now();
    
    // Update position P&L
    if (this.currentPosition.type !== 'NONE') {
      this.updatePositionPnL(currentPrice);
    }
    
    // === CHECK EXIT CONDITIONS ===
    if (this.currentPosition.type !== 'NONE') {
      // Check stop loss
      if (this.currentPosition.unrealizedPnLPercent <= -this.config.stopLossPercent) {
        return this.closePosition(currentPrice, indicators, 
          `Stop Loss: ${this.currentPosition.unrealizedPnLPercent.toFixed(2)}%`);
      }
      
      // Check take profit
      if (this.currentPosition.unrealizedPnLPercent >= this.config.profitTargetPercent) {
        return this.closePosition(currentPrice, indicators,
          `Take Profit: ${this.currentPosition.unrealizedPnLPercent.toFixed(2)}%`);
      }
      
      // Check max position time
      if (timestamp - this.currentPosition.entryTime >= this.config.maxPositionTime) {
        return this.closePosition(currentPrice, indicators,
          `Max Position Time: ${Math.round((timestamp - this.currentPosition.entryTime) / 60000)}min`);
      }
      
      // Check custom exit conditions
      if (this.currentPosition.type === 'LONG' && this.config.longExitConditions) {
        if (this.conditionEvaluator.evaluateGroup(this.config.longExitConditions, indicators)) {
          return this.closePosition(currentPrice, indicators, 'Long Exit Conditions Met');
        }
      }
      
      if (this.currentPosition.type === 'SHORT' && this.config.shortExitConditions) {
        if (this.conditionEvaluator.evaluateGroup(this.config.shortExitConditions, indicators)) {
          return this.closePosition(currentPrice, indicators, 'Short Exit Conditions Met');
        }
      }
      
      // Stay in position
      return {
        type: 'HOLD',
        timestamp,
        price: currentPrice,
        rsi: indicators.rsi,
        ema12: indicators.ema12,
        ema26: indicators.ema26,
        ema50: indicators.ema50,
        ema200: indicators.ema200,
        ma7: indicators.sma7,
        ma25: indicators.sma25,
        ma99: indicators.sma99,
        reason: `In ${this.currentPosition.type} position | P&L: ${this.currentPosition.unrealizedPnLPercent.toFixed(2)}%`,
        position: { ...this.currentPosition }
      };
    }
    
    // === CHECK ENTRY CONDITIONS ===
    
    // Check cooldown
    if (!this.isCooldownPassed()) {
      return {
        type: 'HOLD',
        timestamp,
        price: currentPrice,
        rsi: indicators.rsi,
        ema12: indicators.ema12,
        ema26: indicators.ema26,
        ema50: indicators.ema50,
        ema200: indicators.ema200,
        ma7: indicators.sma7,
        ma25: indicators.sma25,
        ma99: indicators.sma99,
        reason: 'Cooldown period active'
      };
    }
    
    // Check LONG entry
    if (this.conditionEvaluator.evaluateGroup(this.config.longEntryConditions, indicators)) {
      return this.openPosition('LONG', currentPrice, indicators, timestamp);
    }
    
    // Check SHORT entry
    if (this.conditionEvaluator.evaluateGroup(this.config.shortEntryConditions, indicators)) {
      return this.openPosition('SHORT', currentPrice, indicators, timestamp);
    }
    
    // Update condition evaluator with current indicators for next iteration
    this.conditionEvaluator.updatePreviousIndicators(indicators);
    
    // No signal
    return {
      type: 'HOLD',
      timestamp,
      price: currentPrice,
      rsi: indicators.rsi,
      ema12: indicators.ema12,
      ema26: indicators.ema26,
      ema50: indicators.ema50,
      ema200: indicators.ema200,
      ma7: indicators.sma7,
      ma25: indicators.sma25,
      ma99: indicators.sma99,
      reason: 'No entry conditions met'
    };
  }
  
  /**
   * Open a new position
   */
  private openPosition(
    type: 'LONG' | 'SHORT',
    price: number,
    indicators: IndicatorValues,
    timestamp: number
  ): TradingSignal {
    this.currentPosition = {
      type,
      entryPrice: price,
      entryTime: timestamp,
      quantity: this.config.positionSize,
      unrealizedPnL: 0,
      unrealizedPnLPercent: 0
    };
    
    this.lastTradeTime = timestamp;
    
    // Generate reason from conditions
    const conditions = type === 'LONG' 
      ? this.config.longEntryConditions 
      : this.config.shortEntryConditions;
    
    const reason = this.generateSignalReason(conditions, indicators, type);
    
    const signal: TradingSignal = {
      type: type === 'LONG' ? 'BUY' : 'SELL',
      timestamp,
      price,
      rsi: indicators.rsi,
      ema12: indicators.ema12,
      ema26: indicators.ema26,
      ema50: indicators.ema50,
      ema200: indicators.ema200,
      ma7: indicators.sma7,
      ma25: indicators.sma25,
      ma99: indicators.sma99,
      reason,
      position: {
        ...this.currentPosition,
        currentCapital: this.initialCapital + this.totalPnL
      }
    };
    
    this.entrySignal = signal;
    
    // Save open position to database
    OpenPositionRepository.saveOpenPosition(this.config.name, this.currentPosition, this.config.timeframe).catch(err => {
      console.error('Failed to save open position:', err);
    });
    
    return signal;
  }
  
  /**
   * Close current position
   */
  private closePosition(
    exitPrice: number,
    indicators: IndicatorValues,
    reason: string
  ): TradingSignal {
    const timestamp = Date.now();
    const pnl = this.currentPosition.unrealizedPnL;
    const pnlPercent = this.currentPosition.unrealizedPnLPercent;
    
    this.totalPnL += pnl;
    this.totalTrades++;
    const isWin = pnl > 0;
    if (isWin) this.winningTrades++;
    
    // Save completed trade
    const completedTrade: CompletedTrade = {
      strategyName: this.config.name,
      strategyType: this.config.strategyType,
      type: this.currentPosition.type as 'LONG' | 'SHORT',
      entryPrice: this.currentPosition.entryPrice,
      entryTime: this.currentPosition.entryTime,
      entryReason: this.entrySignal?.reason || 'Unknown',
      exitPrice,
      exitTime: timestamp,
      exitReason: reason,
      quantity: this.currentPosition.quantity,
      pnl,
      pnlPercent,
      fees: 0,
      duration: timestamp - this.currentPosition.entryTime,
      isWin,
      timeframe: this.config.timeframe
    };
    
    CompletedTradeRepository.saveCompletedTrade(completedTrade).catch(err => {
      console.error('Failed to save completed trade:', err);
    });
    
    this.completedTrades.unshift(completedTrade);
    
    // Delete open position from database
    OpenPositionRepository.deleteOpenPosition(this.config.name, this.config.timeframe).catch(err => {
      console.error('Failed to delete open position:', err);
    });
    
    const closeSignal: TradingSignal = {
      type: this.currentPosition.type === 'LONG' ? 'CLOSE_LONG' : 'CLOSE_SHORT',
      timestamp,
      price: exitPrice,
      rsi: indicators.rsi,
      ema12: indicators.ema12,
      ema26: indicators.ema26,
      ema50: indicators.ema50,
      ema200: indicators.ema200,
      ma7: indicators.sma7,
      ma25: indicators.sma25,
      ma99: indicators.sma99,
      reason: `${reason} | P&L: ${pnl >= 0 ? '+' : ''}${pnl.toFixed(2)} USDT (${pnlPercent.toFixed(2)}%)`,
      position: {
        ...this.currentPosition,
        unrealizedPnL: pnl,
        unrealizedPnLPercent: pnlPercent,
        totalPnL: this.totalPnL,
        currentCapital: this.initialCapital + this.totalPnL
      }
    };
    
    // Reset position
    this.currentPosition = {
      type: 'NONE',
      entryPrice: 0,
      entryTime: 0,
      quantity: 0,
      unrealizedPnL: 0,
      unrealizedPnLPercent: 0
    };
    
    this.entrySignal = null;
    
    return closeSignal;
  }
  
  /**
   * Update position P&L
   */
  private updatePositionPnL(currentPrice: number): void {
    if (this.currentPosition.type === 'NONE') return;
    
    const priceDiff = currentPrice - this.currentPosition.entryPrice;
    
    if (this.currentPosition.type === 'LONG') {
      this.currentPosition.unrealizedPnL = priceDiff * this.currentPosition.quantity;
      this.currentPosition.unrealizedPnLPercent = (priceDiff / this.currentPosition.entryPrice) * 100;
    } else {
      this.currentPosition.unrealizedPnL = -priceDiff * this.currentPosition.quantity;
      this.currentPosition.unrealizedPnLPercent = (-priceDiff / this.currentPosition.entryPrice) * 100;
    }
  }
  
  /**
   * Update position P&L with current market price
   */
  updatePositionWithCurrentPrice(currentPrice: number): void {
    if (this.currentPosition.type !== 'NONE') {
      this.updatePositionPnL(currentPrice);
    }
  }
  
  /**
   * Check if cooldown period has passed
   */
  private isCooldownPassed(): boolean {
    // If cooldown is null or 0, no cooldown (always passed)
    if (!this.config.cooldownPeriod || this.config.cooldownPeriod === 0) {
      return true;
    }
    return Date.now() - this.lastTradeTime >= this.config.cooldownPeriod;
  }
  
  /**
   * Generate human-readable reason for signal
   */
  private generateSignalReason(
    conditions: ConditionGroup,
    indicators: IndicatorValues,
    type: 'LONG' | 'SHORT'
  ): string {
    const emoji = type === 'LONG' ? 'ðŸ“ˆ' : 'ðŸ“‰';
    const action = type === 'LONG' ? 'Opening LONG' : 'Opening SHORT';
    
    // Get top-level condition descriptions
    const conditionDescriptions = conditions.conditions
      .map(c => getConditionDescription(c, indicators))
      .slice(0, 3) // Show max 3 conditions
      .join(' & ');
    
    return `${emoji} ${action}: ${conditionDescriptions}`;
  }
  
  /**
   * Execute trade
   */
  async executeTrade(signal: TradingSignal): Promise<void> {
    if (signal.type === 'HOLD') return;
    
    if (this.config.simulationMode) {
      const signalEmoji = signal.type === 'BUY' ? 'ðŸ“ˆ' : 
                         signal.type === 'SELL' ? 'ðŸ“‰' : 
                         signal.type === 'CLOSE_LONG' ? 'ðŸ”´' : 
                         signal.type === 'CLOSE_SHORT' ? 'ðŸŸ¢' : 'âšª';
      
      console.log(`${signalEmoji} [${this.config.name}] ${signal.type} at $${signal.price.toFixed(2)}`);
      console.log(`   ${signal.reason}`);
      console.log(`   Stats: P&L: ${this.totalPnL.toFixed(2)} USDT | Trades: ${this.totalTrades} | Win Rate: ${this.getWinRate().toFixed(1)}%`);
    }
  }
  
  /**
   * Get position info
   */
  getPositionInfo() {
    return {
      position: { ...this.currentPosition },
      totalPnL: this.totalPnL,
      totalTrades: this.totalTrades,
      winningTrades: this.winningTrades,
      winRate: this.getWinRate(),
      completedTrades: this.completedTrades,
      currentCapital: this.initialCapital + this.totalPnL
    };
  }
  
  /**
   * Get win rate
   */
  private getWinRate(): number {
    return this.totalTrades > 0 ? (this.winningTrades / this.totalTrades) * 100 : 0;
  }
  
  /**
   * Get current indicators
   */
  getCurrentIndicators(): IndicatorValues | null {
    return this.currentIndicators;
  }
  
  /**
   * Restore from database (completed trades and open positions)
   * DEPRECATED: Use restoreFromDatabaseWithTrades for better performance
   */
  async restoreFromDatabase(): Promise<void> {
    console.log(`ðŸ“¥ [${this.config.name}] Restoring from database...`);
    
    // Reset
    this.totalTrades = 0;
    this.winningTrades = 0;
    this.totalPnL = 0;
    this.completedTrades = [];
    
    // Restore open position for this specific timeframe
    const openPosition = await OpenPositionRepository.getOpenPosition(this.config.name, this.config.timeframe);
    if (openPosition && openPosition.type !== 'NONE') {
      this.currentPosition = openPosition;
      console.log(`   Restored open ${openPosition.type} position @ ${openPosition.entryPrice.toFixed(2)} [${this.config.timeframe}]`);
    }
    
    // Load ALL completed trades for this strategy (ALL timeframes) - NO LIMIT for true all-time stats
    const completedTrades = await CompletedTradeRepository.getCompletedTradesByStrategy(
      this.config.name, 
      0, // 0 = no limit, load ALL trades
      undefined // undefined = load ALL timeframes
    );
    this.completedTrades = completedTrades;
    
    this.totalTrades = completedTrades.length;
    this.winningTrades = completedTrades.filter(t => t.isWin).length;
    this.totalPnL = completedTrades.reduce((sum, t) => sum + t.pnl, 0);
    
    console.log(`âœ… [${this.config.name}] Restored: ${this.totalTrades} trades (all timeframes), Win Rate: ${this.getWinRate().toFixed(1)}%, P&L: ${this.totalPnL.toFixed(2)} USDT`);
  }
  
  /**
   * Restore from database with pre-loaded trades (OPTIMIZED)
   * Trades and positions are loaded in bulk by StrategyManager to avoid multiple queries
   * @param preloadedTrades - All trades for this strategy (all timeframes)
   * @param preloadedPosition - Open position for this strategy+timeframe (optional)
   */
  async restoreFromDatabaseWithTrades(preloadedTrades: any[], preloadedPosition?: any): Promise<void> {
    // Reset
    this.totalTrades = 0;
    this.winningTrades = 0;
    this.totalPnL = 0;
    this.completedTrades = [];
    
    // Restore open position (use pre-loaded if available)
    if (preloadedPosition && preloadedPosition.type !== 'NONE') {
      this.currentPosition = preloadedPosition;
      console.log(`ðŸ“¥ [${this.config.name}][${this.config.timeframe}] Position: ${preloadedPosition.type} @ ${preloadedPosition.entryPrice.toFixed(2)}`);
    }
    
    // Use pre-loaded trades (already filtered by strategy name, all timeframes)
    this.completedTrades = preloadedTrades;
    this.totalTrades = preloadedTrades.length;
    this.winningTrades = preloadedTrades.filter(t => t.isWin).length;
    this.totalPnL = preloadedTrades.reduce((sum, t) => sum + t.pnl, 0);
    
    console.log(`âœ… [${this.config.name}][${this.config.timeframe}] ${this.totalTrades} trades, WR: ${this.getWinRate().toFixed(1)}%, P&L: ${this.totalPnL.toFixed(2)} USDT`);
  }
  
  /**
   * Get strategy configuration
   */
  getConfig(): CustomStrategyConfig {
    return { ...this.config };
  }
  
  /**
   * Update strategy configuration
   */
  updateConfig(config: Partial<CustomStrategyConfig>): void {
    this.config = { ...this.config, ...config };
  }
}

// === PRESET STRATEGY CONFIGURATIONS ===

export const PresetStrategies = {
  /**
   * RSI + EMA Mean Reversion Strategy
   */
  rsiEma: (): CustomStrategyConfig => ({
    name: 'RSI + EMA Strategy',
    description: 'Mean reversion strategy using RSI oversold/overbought and EMA trend confirmation',
    strategyType: 'RSI_EMA',
    
    longEntryConditions: {
      operator: 'AND',
      conditions: [
        { type: 'comparison', indicator: 'rsi', operator: 'LT', value: 30 },
        { type: 'boolean', indicator: 'isBullishTrend', value: true }
      ]
    },
    
    shortEntryConditions: {
      operator: 'AND',
      conditions: [
        { type: 'comparison', indicator: 'rsi', operator: 'GT', value: 70 },
        { type: 'boolean', indicator: 'isBearishTrend', value: true }
      ]
    },
    
    profitTargetPercent: 2.5,
    stopLossPercent: 1.5,
    maxPositionTime: 60 * 60 * 1000,
    positionSize: 0.05, // 5% capital (Balanced)
    cooldownPeriod: 5 * 60 * 1000,
    timeframe: '1m',
    simulationMode: true
  }),
  
  /**
   * Bollinger Bounce Strategy
   */
  bollingerBounce: (): CustomStrategyConfig => ({
    name: 'Bollinger Bounce',
    description: 'Buy at lower band, sell at upper band with RSI confirmation',
    strategyType: 'BOLLINGER_BOUNCE',
    
    longEntryConditions: {
      operator: 'AND',
      conditions: [
        { type: 'boolean', indicator: 'isNearBBLower', value: true },
        { type: 'comparison', indicator: 'rsi', operator: 'LT', value: 45 }
      ]
    },
    
    shortEntryConditions: {
      operator: 'AND',
      conditions: [
        { type: 'boolean', indicator: 'isNearBBUpper', value: true },
        { type: 'comparison', indicator: 'rsi', operator: 'GT', value: 55 }
      ]
    },
    
    profitTargetPercent: 1.8,
    stopLossPercent: 2.0,
    maxPositionTime: 120 * 60 * 1000,
    positionSize: 0.05, // 5% capital (Balanced)
    cooldownPeriod: 2 * 60 * 1000,
    timeframe: '1m',
    simulationMode: true
  }),
  
  /**
   * Trend Follower Strategy
   */
  trendFollower: (): CustomStrategyConfig => ({
    name: 'Trend Follower',
    description: 'Follow the trend using EMA50 as filter',
    strategyType: 'TREND_FOLLOWER',
    
    longEntryConditions: {
      operator: 'AND',
      conditions: [
        { type: 'boolean', indicator: 'isUptrend', value: true },
        { type: 'boolean', indicator: 'isBullishTrend', value: true }
      ]
    },
    
    shortEntryConditions: {
      operator: 'AND',
      conditions: [
        { type: 'boolean', indicator: 'isDowntrend', value: true },
        { type: 'boolean', indicator: 'isBearishTrend', value: true }
      ]
    },
    
    // Add custom exit conditions to close on trend reversal
    longExitConditions: {
      operator: 'OR',
      conditions: [
        { type: 'boolean', indicator: 'isDowntrend', value: true }
      ]
    },
    
    shortExitConditions: {
      operator: 'OR',
      conditions: [
        { type: 'boolean', indicator: 'isUptrend', value: true }
      ]
    },
    
    profitTargetPercent: 2.0,
    stopLossPercent: 2.0,
    maxPositionTime: 240 * 60 * 1000,
    positionSize: 0.05, // 5% capital (Balanced)
    cooldownPeriod: 0, // No cooldown for trend following
    timeframe: '1m',
    simulationMode: true
  })
};

